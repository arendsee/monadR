[![Travis-CI Build Status](https://travis-ci.org/arendsee/rmonad.svg?branch=dev)](https://travis-ci.org/arendsee/rmonad)
[![Coverage Status](https://img.shields.io/codecov/c/github/arendsee/rmonad/dev.svg)](https://codecov.io/github/arendsee/rmonad?branch=dev)

---
output: markdown_github 
---

<!-- README.md is generated from README.Rmd. Please edit that file -->


```{r, echo = FALSE}
set.seed(210)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# `rmonad`

Chain monadic sequences into stateful, branching pipelines.

You may use `rmonad` to

 * build linear pipelines, as with `magrittr`

 * access results at any step within the pipeline

 * access results preceding an error

 * handle errors naturally

 * call effects -- e.g. plotting, caching -- within a pipeline

 * branch or merge pipelines, while preserving their history

 * annotate nodes in the graph

 * benchmark a pipeline to find bottleknecks in time and space 


## Installation

You can install from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("arendsee/rmonad")
```

## Examples

For details, see the vignette. Here are a few excerpts

```{r}
library(rmonad)
```


### Record history and access inner values

```{r}
1:5      %>>%
    sqrt %v>% # record an intermediate value
    sqrt %>>%
    sqrt
```


### Add effects inside a pipeline

```{r, eval=FALSE}
# Both plots and summarizes an input table
cars %>_% plot(xlab="index", ylab="value") %>>% summary
```


### Use first successful result

```{r}
x <- list()

# return first value in a list, otherwise return NULL
if(length(x) > 0) {
    x[[1]]
} else {
    NULL
}

# this does the same
x[[1]] %||% NULL %>% esc
```


### Independent evaluation of multiple expressions

```{r}
lsmeval(
    runif(5),
    stop("stop, drop and die"),
    runif("df"),
    1:10
)
```


### Build branching pipelines

```{r, eval=FALSE}
lsmeval(
    read.csv("a.csv") %>>% do_analysis_a,
    read.csv("b.csv") %>>% do_analysis_b,
    k = 5
) %*>% joint_analysis
```


### Chain independent pipelines, with documentation

```{r}
analysis <- 
{
    "This analysis begins with 5 uniform random variables"

    runif(5)

} %>>% '^'(2) %>>% sum %__%
{
    "The next step is to take 6 normal random variables"

    rnorm(6)  
} %>>% '^'(2) %>>% sum %v__%
{
    "And this is were the magic happens, we take 'a' random normal variables"

    rnorm("a")

} %>>% '^'(2) %>>% sum %__%
{
    "Then, just for good measure, we toss in six exponentials"

    rexp(6)

} %>>% '^'(2) %>>% sum

analysis
```
