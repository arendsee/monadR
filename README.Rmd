[![Travis-CI Build Status](https://travis-ci.org/arendsee/rmonad.svg?branch=master)](https://travis-ci.org/arendsee/rmonad)
[![Coverage Status](https://img.shields.io/codecov/c/github/arendsee/rmonad/master.svg)](https://codecov.io/github/arendsee/rmonad?branch=master)

---
output: markdown_github 
---

<!-- README.md is generated from README.Rmd. Please edit that file -->


```{r, echo = FALSE}
set.seed(210)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# `rmonad`

Chain monadic sequences into stateful, branching pipelines.

You may use `rmonad` to

 * build linear pipelines, as with `magrittr`

 * access results at any step within the pipeline

 * access results preceding an error

 * handle errors naturally

 * call effects -- e.g. plotting, caching -- within a pipeline

 * branch or merge pipelines, while preserving their history

 * annotate nodes in the graph

 * benchmark a pipeline to find bottleknecks in time and space 


## Installation

You can install from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("arendsee/rmonad")
```

## Examples

For details, see the vignette. Here are a few excerpts

```{r}
library(rmonad)
```


### Record history and access inner values

```{r}
1:5      %>>%
    sqrt %v>% # record an intermediate value
    sqrt %>>%
    sqrt
```


### Add effects inside a pipeline

```{r}
# Both plots and summarizes an input table
cars %>_% plot(xlab="index", ylab="value") %>>% summary
```


### Use first successful result

```{r}
x <- list()

# return first value in a list, otherwise return NULL
if(length(x) > 0) {
    x[[1]]
} else {
    NULL
}

# this does the same
x[[1]] %||% NULL %>% esc
```


### Independent evaluation of multiple expressions

```{r}
lsmeval(
    runif(5),
    stop("stop, drop and die"),
    runif("df"),
    1:10
)
```


### Build branching pipelines

```{r, eval=FALSE}
lsmeval(
    read.csv("a.csv") %>>% do_analysis_a,
    read.csv("b.csv") %>>% do_analysis_b,
    k = 5
) %*>% joint_analysis
```


### Chain independent pipelines, with documentation

```{r}
runif(5) %>>% abs %>% doc(

    "Alternatively, the documentation could go into a text block below the code
    in a knitr document. The advantage of having documentation here, is that it
    is coupled unambiguously to the generating function. These annotations,
    together with the ability to chain chains of monads, allows whole complex
    workflows to be built, with the results collated into a single object. All
    errors propagate exactly as errors should, only affecting downstream
    computations. The final object can be converted into a markdown document
    and automatically generated function graphs."

                  ) %>^% sum %__%
rnorm(6)   %>>% abs %>^% sum %v__%
rnorm("a") %>>% abs %>^% sum %__%
rexp(6)    %>>% abs %>^% sum %T>%
  { print(mtabulate(.)) } %>% missues
```
