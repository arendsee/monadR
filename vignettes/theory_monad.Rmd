---
title: "What is this 'monad' thing?"
author: "Zebulun Arendsee"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{What is this 'monad' thing?}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

What does `sqrt` do? You may answer, "return the square root of an input". But
this is not quite right. The function `sqrt` maps to a set of possible values.

 * when x is numeric and $x > 0$ : $\sqrt{x}$ 
 * when x is numeric and $x \le 0$ : `NA` and a warning effect
 * when x is not numeric : an error effect that propagates downstream

Every R function maps a pure value to a computational context with possible
undefined behavior and side effects. We can describe the action of a function
abstractly as

```
    a -> m b
```

Where `a` is the pure input value, `b` is the pure output value, and `m`
represents the context. The `sqrt` function can be described as `number -> m
number`.

When we build a pipeline, we chain many functions together. Say, for example,
we have the expression:

```
sqrt(sum(x))
```

Borrowing a bit of Haskell syntax

```
sqrt :: numeric* -> m numeric*
sum  :: numeric* -> m numeric*
```

`numeric*` represents something that should be numeric. Since R is dynamically
typed, we have no guaranttees that the input actually is numeric. The important
thing to note is that each function takes a pure value and maps to a value
wrapped in a context. `sum(x)` outputs `m numeric*`, but `sqrt` wants a
`numeric*`. We need a function to mediate this. We need a function of the form:

```
bind :: (m numeric*) -> (numeric* -> m numeric*) -> (m numeric*) 
           ^                ^                           ^
          /                /                           /
      sum(x)            sqrt                   sqrt(sum(x))
```

We can express this more generally as

```
bind :: m1 a -> (a -> m2 b) -> m3 b
```

Where `a` and `b` are data types. `m1`, `m2` and `m3` are contexts. Every bind
operation takes 1) a value in a context (`m1 a`) and 2) a function that maps
that value to `m2 b`. The prior state `m1`, as well as the intermediate state
`m2`, are in the scope of the `bind` function. This allows contextual
information to propagate from the `m1` to `m2`.

A monad is a pattern consisting of a context `m`, two functions, and three
laws. The functions are `bind` and `return` (not to be confused with the
`return` used to terminate a function). `bind` we have already seen. `return`
takes a pure value and lifts it into a context.

FLOTSAM

introduce laws

contrast with magrittr (the identity monad)

`m b` is dependent on `m a`, not just on `a`. The `bind` function can pass
information from one step in the pipeline `m a` to the next `m b`.

`m2 b` is equal to `m3 b` only for the trivial case where the context is
`identity`.  

R users normally rely on the R session to automatically perform these binds. 

But what exactly is `m`? In an R sesion, the R runtime handles errors. If one
function raises an error, the error is propagated to functions that use its
input.

In Rmonad, the `m` is an object, that catches all undefined behavior.
