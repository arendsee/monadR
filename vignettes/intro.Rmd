---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
library(rmonad)
library(magrittr)
```

This simplest use of `monadR` is simply to propagate a failed state through a
program.

```{r}
read.table("adsfdfd") %$>% colSums %>>% mean
```

```{r}
r1 <- read.table("asdfdf") %$>% colSums %>>% mean  # dies on read.table
r2 <- iris %$>% colSums %>>% mean                  # dies on colSums 
r3 <- cars %$>% colSums %>>% mean                  # passes
```

The pipeline can branch is the `%>^%` operator:

```{r}
rnorm(100) %>^% plot(xlab="index", ylab="value") %>>% mean
```

This stores the result of `plot` in a branch off the main pipeline. This means
that `plot` could fail, but the rest of the pipeline could continue. You can
store multiple branches.

```{r}
rnorm(100) %>^% plot(xlab="index", ylab="value") %>^% summary %>>% mean
```

Branches can be used as input, as well.

```{r}
x <- 1:10 %>^% dgamma(10, 1) %>^% dgamma(10, 5) %^>% pmax()
x
x@history[[2]]@branch
```

Note the branches could be long monadic chains themselves, which might have
their own branches.

The `%>_%` operator is useful when you want to include a function inside a
pipeline that should be bypassed, but you want the errors, warnings, and
messages to pass along with the main. This can be used make assertions about
the data inside a pipeline.

```{r}
is_positive <- function(x) { stopifnot(x > 0) }
rnorm(100) %>_% is_positive %>>% mean
```

This can also be used for documentation

```{r}
# note is just `function(...) { }`, here I use it to document, since
# Rmonad shows the functions called via NSE.
rnorm(100) %>_% note("I am about to take the mean") %>>% mean
```

Sometimes failure is not the end of the world. For example, we might want to
try several alternatives functions, and use the first that works. 

```{r}
1:10 %$>% colSums %?>% sum
```

Here we will do either `colSums` or `sum`. The pipeline fails only if both
fail.

This operator can also be used as a pure try-catch:

```{r}
id <- function(x) x
iris %$>% colSums %?>% id %>>% summary
cars %$>% colSums %?>% id %>>% summary
```

In this way, we can make chains of operations which may fail for some inputs.
These failures are recorded in the monad, but don't scream and break things.

Sometimes you want to ignore the previous failure completely, and make a new
call -- for example in reading files:

```{r}
# try to load a cached file, on failure rerun the analysis
"analyasis_cache.tab" %$>% read.table %?<% the_analysis(x)
```


```{r, eval=FALSE}
read(datafile) %,=% "data"   %,,%
read(config)   %,=% "config" %,>% dothething
```
