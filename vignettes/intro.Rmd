---
title: "Introduction to Rmonad"
author: "Zebulun Arendsee"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Introduction to Rmonad}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

If you are not already familiar with monads, you might first reference this
tutorials: ["functors, applicatives, and monads in
pictures"](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)


```{r}
library(rmonad)
library(magrittr)
library(tibble)
set.seed(210)
```

I will introduce `Rmonad` with a simple sequence of squares

```{r}
# %>>% corresponds to Haskell's >>=
1:5      %>>%
    sqrt %>>%
    sqrt %>>%
    sqrt
```

So what exactly did Rmonad do with your data? It is still there, but it is
inside the monad, and it doesn't ever need to come out.

In `magrittr` you could do something similar:

```{r}
1:5      %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

`magrittr` is standard pipeline, chaining data to output data. `Rmonad` is
quite different, it uses builds monadic sequences, which preserve state between
calls. The preserved state allows us to access data internal to the pipeline:

```{r}
1:5      %>>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The `%v>%` variant of the bind operator stores the results as they are passed.

Now lets look at warnings handling.

```{r}
-1:3     %>>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

`Rmonad` intercepts all errors, warnings, and messages and anchors them to the
function that produced them. Similarly for errors:

```{r}
letters  %>>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The input to the first `sqrt` failed, and was coupled to the resultant error.
Contrast this with `magrittr`:

```{r, error=TRUE}
letters  %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

Also note that a value was still produced. `Rmonad` stores the last successful
value. It will never use this value, though, unless you use a specific operator
(which we will see in a bit).

If you want to extract the result from the monad, you can use the `esc`
function:

```{r}
1:5 %>>% sqrt %>% esc
```

Note the use of `$>$` not `%>>%`, this is because `esc` acts on the monad, not
the value the monad stores. If the monad is in a failed state, `esc` will raise
an error.


Here is a more substantial example

```{r}
# convert to tibbles for cleaner printing
r1 <- read.table("asdfdf") %>>% tibble::as_tibble %>>% colSums %>>% mean
r2 <- iris %>>% tibble::as_tibble %>>% colSums %>>% mean
r3 <- cars %>>% tibble::as_tibble %>>% colSums %>>% mean
```

# Branching out

If you want to perform an operation on a value inside the chain, but don't want
to pass it, you can use the branch operator `%>^%`.

```{r}
pass(rnorm(30)) %>^% plot(xlab="index", ylab="value") %>>% mean
```

This stores the result of `plot` in a branch off the main pipeline. This means
that `plot` could fail, but the rest of the pipeline could continue. You can
store multiple branches.

```{r}
rnorm(30) %>^% plot(xlab="index", ylab="value") %>^% summary %>>% mean
```

Branches can be used as input, as well.

```{r}
x <- 1:10 %>^% dgamma(10, 1) %>^% dgamma(10, 5) %^>% pmax()
x
unbranch(x)
```

Note the branches could be long monadic chains themselves, which might have
their own branches. The `unbranch` function recursively extracts all branches
from the tree.

The `%>_%` operator is useful when you want to include a function inside a
pipeline that should be bypassed, but you want the errors, warnings, and
messages to pass along with the main. This can be used make assertions about
the data inside a pipeline.

```{r}
is_positive <- function(x) { stopifnot(x > 0) }
rnorm(30) %>_% is_positive %>>% mean
```

Sometimes failure is not the end of the world. For example, we might want to
try several alternatives functions, and use the first that works. 


# Handling error

```{r}
1:10 %>>% colSums %?>% sum
```

Here we will do either `colSums` or `sum`. The pipeline fails only if both
fail.

This operator can also be used as a pure try-catch:

```{r}
iris %>>% tibble::as_data_frame %>>% colSums %?>% ident %>>% summary
cars %>>% tibble::as_data_frame %>>% colSums %?>% ident %>>% summary
```

Where `ident` is the identity function. In this way, we can make chains of
operations which may fail for some inputs. These failures are recorded in the
monad, but don't scream and break things.

Sometimes you want to ignore the previous failure completely, and make a new
call -- for example in reading files:

```{r}
# try to load a cached file, on failure rerun the analysis
"analyasis_cache.tab" %>>% read.table %?<% the_analysis(x)
```

```{r, eval=FALSE}
read(datafile) %,=% "data"   %,,%
read(config)   %,=% "config" %,>% dothething
```

# Chains of chains

If you want to connect many chains, all with independent inputs, you can do so
with the `%__%` and `%v__%` operators.

```{r}
runif(10) %>>% sum %v__%
rnorm(10) %>>% sum %v__%
rexp(10)  %>>% sum
```

The `%v__%` operator records the output of the lhs and evaluates the rhs into
an Rmonad. If you don't care about the output, you can use `%__%`, which simply
replaces the rhs value with lhs value (while, of course, propagating state).

If you won't the success of one stage to be dependent on the prior stage, you
can use the branch operator:

```{r}
x <- runif(10) %>>% sum %^__%
     rnorm(10) %>>% sum %^__%
     rexp(10)  %>>% sum
unbranch(x)
```

Note the use of magrittr's `%>%` to perform an operation on the monad itself,
rather than its value.

`unbranch` returns a list of all branches in the tree. Here is a more dramatic picture.

```{r}
runif(10)  %>>% abs %>^% sum %^__%
rnorm(10)  %>>% abs %>^% sum %^__%
rnorm("a") %>>% abs %>^% sum %^__%
rexp(10)   %>>% abs %>^% sum %>%
    unbranch
```

Now it is getting a little hard to remember what is what. It would be nice if
we could document our data. We can do that as follows:

```{r}
runif(10)  %>>% abs %>% doc(
    "I take the absolute value of the input here, even though it is already
    guaranteed to be positive(since it is from a uniform distribution on the
    range 0 to 1). This is necessary, because otherwise the vertical lines in
    my code would not line up. That would irritate me."
                  ) %>^% sum %^__%
rnorm(10)  %>>% abs %>^% sum %^__%
rnorm("a") %>>% abs %>^% sum %^__%
rexp(10)   %>>% abs %>^% sum %>%
    unbranch
```
