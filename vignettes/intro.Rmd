---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
library(rmonad)
library(magrittr)
library(tibble)
set.seed(210)
```

I will introduce `Rmonad` with a simple sequence of squares

```{r}
1:5      %$>%
    sqrt %>>%
    sqrt %>>%
    sqrt
```

So what exactly did Rmonad do with your data? It is still there, but it is
inside the monad, and it doesn't ever need to come out. You see that soon. 

In `magrittr` you could do something similar:

```{r}
1:5      %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

`magrittr` is standard pipeline, chaining data to output data. `Rmonad` is
quite different, it uses builds monadic sequences, which preserve state between
calls. The preserved state allows us to access data internal to the pipeline:

```{r}
1:5      %$>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The `%v>%` variant of the bind operator stores the results as they are passed.

Now lets look at warnings handling.

```{r}
-1:3     %$>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

`Rmonad` intercepts all errors, warnings, and messages and anchors them to the
function that produced them. Similarly for errors:

```{r}
letters  %$>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The input to the first `sqrt` failed, and was coupled to the resultant error.
Contrast this with `magrittr`:

```{r, eval=FALSE}
letters  %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

Also note that a value was still produced. `Rmonad` stores the last successful
value. It will never use this value, though, unless you use a specific operator
(which we will see in a bit).

Here is a more substantial example

```{r}
# convert to tibbles for cleaner printing
r1 <- read.table("asdfdf") %$>% tibble::as_data_frame %>>% colSums %>>% mean
r2 <- iris %$>% tibble::as_data_frame %>>% colSums %>>% mean
r3 <- cars %$>% tibble::as_data_frame %>>% colSums %>>% mean
```

You may have noticed that the first operator in each chain is `%$>%`, whereas
the following operators are `$>>$`. The former operator takes the left hand
value and wraps it in a monad, and then performs the left hand function on its
value. The `$>>$` operator, takes a monadic container on the left and applies
its value (if it didn't fail) to the function on the right, then unifies the
history.


# Branching out

If you want to perform an operation on a value inside the chain, but don't want
to pass it, you can use the branch operator `%>^%`.

```{r}
pass(rnorm(30)) %>^% plot(xlab="index", ylab="value") %>>% mean
```

This stores the result of `plot` in a branch off the main pipeline. This means
that `plot` could fail, but the rest of the pipeline could continue. You can
store multiple branches.

```{r}
rnorm(30) %>^% plot(xlab="index", ylab="value") %>^% summary %>>% mean
```

Branches can be used as input, as well.

```{r}
x <- 1:10 %>^% dgamma(10, 1) %>^% dgamma(10, 5) %^>% pmax()
x
x@history[[2]]@branch
```

Note the branches could be long monadic chains themselves, which might have
their own branches.

The `%>_%` operator is useful when you want to include a function inside a
pipeline that should be bypassed, but you want the errors, warnings, and
messages to pass along with the main. This can be used make assertions about
the data inside a pipeline.

```{r}
is_positive <- function(x) { stopifnot(x > 0) }
rnorm(30) %>_% is_positive %>>% mean
```

This can also be used for documentation

```{r}
# note is just `function(...) { }`, here I use it to document, since
# Rmonad shows the functions called via NSE.
rnorm(30) %>_% note("I am about to take the mean") %>>% mean
```

Sometimes failure is not the end of the world. For example, we might want to
try several alternatives functions, and use the first that works. 


# Handling error

```{r}
1:10 %$>% colSums %?>% sum
```

Here we will do either `colSums` or `sum`. The pipeline fails only if both
fail.

This operator can also be used as a pure try-catch:

```{r}
id <- function(x) x
iris %$>% tibble::as_data_frame %>>% colSums %?>% id %>>% summary
cars %$>% tibble::as_data_frame %>>% colSums %?>% id %>>% summary
```

In this way, we can make chains of operations which may fail for some inputs.
These failures are recorded in the monad, but don't scream and break things.

Sometimes you want to ignore the previous failure completely, and make a new
call -- for example in reading files:

```{r}
# try to load a cached file, on failure rerun the analysis
"analyasis_cache.tab" %$>% read.table %?<% the_analysis(x)
```

```{r, eval=FALSE}
read(datafile) %,=% "data"   %,,%
read(config)   %,=% "config" %,>% dothething
```

# What is a monad?

## A little background syntax

To describe what a monad is I first need to introduce a little syntax for
specifying functions. I am pulling this syntax roughly from Haskell (the
language where monads are most well developed). The function `max`, which takes
the maximum of two numbers can be specified as follows:

```
max :: Numeric -> Numeric -> Numeric
           ^         ^           ^
          /         /           /
 arg1 ---'  arg2 --'  result --'
```

While the function `max` takes specifically numeric arguments, some functions
can take arguments of any type. These type variables can be expressed with
single, lowercase letters. For example, a function that takes two arguments and
return the first argument would have the signature `a -> b -> a`.

Some types are also parameterized. For example, a homogenous list is
a parameterized type. A function that returns the nth element from a list might
have the signature:

```
nth :: List a -> Integer -> a
```

Where `List a` means a list of elements of type `a`, where `a` can be anything.
Now `List` could be replaced with generic value:

```
nth :: OrderedContainer l => l a -> Integer -> a
```

The term `OrderedContainer l` is a *constraint* on what values `l` can take. So
in R, this `l` might refer to a list, an atomic vector, a data.frame, or any of
the other types that are indexed.

## The monad definition

A monad is a parameterized type `m` for which the following two functions are
defined:

```
wrap :: a -> m a
bind :: m a -> (a -> m b) -> m b
```

The function `wrap` (or `return` in Haskell) takes a value and lifts it into
the monad. The `bind` function takes the value of type `a` wrapped in the monad
`m`, applies a function to it that produces `b` wrapped in a new monad. Note
that this is not the same as

```
bind :: m a -> (a -> b) -> m b   ### WRONG
```

We are not just applying a function to the value wrapped in the monad. `bind`
can be broken down into two pieces:

```
fmap :: m a -> (a -> m b) -> m (m b)
join :: m (m b) -> m b
```

`fmap` looks into `m a` and transforms `a` with the function `a -> m b`, which
results in something of type `m (m b)`. `join` then takes this nested monad and
converts it into the final form `m b`.
