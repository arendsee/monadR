---
title: "Rmonad: running with monads"
author: "Zebulun Arendsee"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Running with monads}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

If you are not already familiar with monads, you might first reference this
tutorial: ["functors, applicatives, and monads in
pictures"](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)


```{r, echo=FALSE}
library(rmonad)
library(magrittr)
library(tibble)
library(ggplot2)
set.seed(210)
```

`Rmonad` offers

 * a nuanced way to handle errors

 * a means to access results inside a pipeline

 * handling for effects -- e.g. plotting, caching -- within a pipeline

 * access to results preceding an error

 * tools for branching and combining pipelines

 * a more formal approach to literate programming



I will introduce `Rmonad` with a simple sequence of squares

```{r}
# %>>% corresponds to Haskell's >>=
1:5      %>>%
    sqrt %>>%
    sqrt %>>%
    sqrt
```

So what exactly did Rmonad do with your data? It is still there, sitting
happily inside the monad.

In `magrittr` you could do something similar:

```{r}
1:5      %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

`%>%` takes the value on the left and applies it to the function on the right..
`Rmonad`, takes a monad on the left and a function on the right, then builds a
new monad from them. This new monad holds the computed value, if the
computation succeeded. It collates all errors, warnings, and messages.  These
are stored in step-by-step a history of the pipeline.

`%>%` is an application operator, `%>>%` is a *monadic bind* operator. Magrittr
and Rmonad complement eachother. `%>%` can be used inside a monadic sequence to
perform operations *on* monads, whereas `%>>%` performs operations *in* them.
If this sounds too mystical, just hold on, the examples are sensical even
without an understanding of monads.

Below, we store an intermediate value in the monad:

```{r}
1:5      %>>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The `%v>%` variant of the *monadic bind* operator stores the results as they
are passed.

Warnings are caught and stored

```{r}
-1:3     %>>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

Similarly for errors

```{r}
letters  %>>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The first `sqrt` failed, and this step was coupled to the resultant error.
Contrast this with `magrittr`, where the location of the error is lost:

```{r, error=TRUE}
letters  %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

Also note that a value was still produced. `Rmonad` stores the last successful
value. It will never use this value, though, unless you use a specific operator
(which we will see in a bit).

If you want to extract the result from the monad, you can use the `esc`
function:

```{r}
1:5 %>>% sqrt %>% esc
```

Note the use of `$>$` not `%>>%`, this is because `esc` acts on the monad, not
the value the monad stores. If the monad is in a failed state, `esc` will raise
an error.


```{r, error=TRUE}
letters %>>% sqrt %>>% sqrt %>% esc
```

Here is a more substantial example

```{r}
# convert to tibbles for cleaner printing
r1 <- read.table("asdfdf") %>>% tibble::as_tibble %>>% colSums %>>% mean
r2 <- iris %>>% tibble::as_tibble %>>% colSums %>>% mean
r3 <- cars %>>% tibble::as_tibble %>>% colSums %>>% mean
```

# Adding effects

The `%>_%` operator is useful when you want to include a function inside a
pipeline that should be bypassed, but you want the errors, warnings, and
messages to pass along with the main. This can be used make assertions about
the data inside a pipeline.

```{r}
is_positive <- function(x) { stopifnot(x > 0) }
rnorm(30) %>_% is_positive %>>% mean
```

Or you can cache an intermediate result


```{r}
cars %>_% write.csv(file="cars.tab") %>>% summary
```

Or to plot a value along with a summary

```{r}
cars %>_% plot(xlab="index", ylab="value") %>>% summary %>% forget
```

I pipe the final monad into `forget`, which is (like `esc`) a function for
operating on monads. `forget` removes history from a monad. I do this just to
de-clutter the output.

# Handling error

Sometimes failure is not the end of the world. For example, we might want to
try several alternatives functions, and use the first that works. 

```{r}
1:10 %>>% colSums %|>% sum
```

Here we will do either `colSums` or `sum`. The pipeline fails only if both
fail.

This operator can also be used as a pure try-catch:

```{r}
iris %>>% tibble::as_data_frame %>>% colSums %|>% ident %>>% summary
cars %>>% tibble::as_data_frame %>>% colSums %|>% ident %>>% summary
```

Where `ident` is the identity function. In this way, we can make chains of
operations which may fail for some inputs.

Sometimes you want to ignore the previous failure completely, and make a new
call -- for example in reading files:

```{r, eval=FALSE}
# try to load a cached file, on failure rerun the analysis
read.table("analyasis_cache.tab") %||% run_analysis(x)
```

This can also be used to replace if-else if-else strings

```{r}
x <- list()
# compare
if(length(x) > 0) { x[[1]] } else { NULL }
# to 
x[[1]] %||% NULL %>% esc
```

Or maybe you want to support multiple extensions for an input file

```{r, eval=FALSE}
read.table("a.tab") %||% read.table("a.tsv") %>>% dostuff
```


# Branching Out

If you want to perform an operation on a value inside the chain, but don't want
to pass it, you can use the branch operator `%>^%`.

```{r}
rnorm(30) %>^% qplot(xlab="index", ylab="value") %>>% mean %>% unbranch
```

This stores the result of `qplot` in a branch off the main pipeline. This means
that `plot` could fail, but the rest of the pipeline could continue. You can
store multiple branches.

```{r}
rnorm(30) %>^% plot(xlab="index", ylab="value") %>^% summary %>>% mean
```

Branches can be used as input, as well.

```{r}
x <- 1:10 %>^% dgamma(10, 1) %>^% dgamma(10, 5) %^>% pmax()
x
unbranch(x)
```

Note the branches could be long monadic chains themselves, which might have
their own branches. The `unbranch` function recursively extracts all branches
from the tree.


# Chains of chains

If you want to connect many chains, all with independent inputs, you can do so
with the `%__%` and `%v__%` operators.

```{r}
runif(10) %>>% sum %v__%
rnorm(10) %>>% sum %v__%
rexp(10)  %>>% sum
```

The `%v__%` operator records the output of the lhs and evaluates the rhs into
an Rmonad. If you don't care about the output, you can use `%__%`, which simply
replaces the rhs value with lhs value (while, of course, propagating state).

If you won't the success of one stage to be dependent on the prior stage, you
can use the branch operator:

```{r}
x <- runif(10) %>>% sum %^__%
     rnorm(10) %>>% sum %^__%
     rexp(10)  %>>% sum
unbranch(x)
```

Note the use of magrittr's `%>%` to perform an operation on the monad itself,
rather than its value.

`unbranch` returns a list of all branches in the tree. Here is a more dramatic picture.

```{r}
runif(10)  %>>% abs %>^% sum %^__%
rnorm(10)  %>>% abs %>^% sum %^__%
rnorm("a") %>>% abs %>^% sum %^__%
rexp(10)   %>>% abs %>^% sum %>%
    unbranch
```

# Annotating steps

Now it is getting a little hard to remember what is what. It would be nice if
we could document our data. We can do that as follows:

```{r}
runif(10)  %>>% abs %>% doc(

    "Alternatively, the documentation could go into a text block below the code
in a knitr document. The advantage of having documentation here, is that it is
coupled unambiguously to the generating function. This is a monadic
interpretation of literate programming. These annotations, together with the
ability to chain chains of monads, allows whole complex workflows to be built,
with the results collated into a single monad. All errors propagate exactly as
errors should, only affecting downstream computations. The final monad can be
converted into a markdown document. A graph of functions can automatically be
built. Summaries of the locations of errors. The monad could be extended for
automated benchmarking."

                  ) %>^% sum %^__%
rnorm(10)  %>>% abs %>^% sum %^__%
rnorm("a") %>>% abs %>^% sum %^__%
rexp(10)   %>>% abs %>^% sum %>%
    unbranch
```
