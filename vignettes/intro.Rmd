---
title: "Introduction to Rmonad"
author: "Zebulun Arendsee"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Introduction to Rmonad}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

If you are not already familiar with monads, you might first reference this
tutorials: ["functors, applicatives, and monads in
pictures"](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)


```{r}
library(rmonad)
library(magrittr)
library(tibble)
set.seed(210)
```

I will introduce `Rmonad` with a simple sequence of squares

```{r}
# %>>% corresponds to Haskell's >>=
1:5      %$>%
    sqrt %>>%
    sqrt %>>%
    sqrt
```

So what exactly did Rmonad do with your data? It is still there, but it is
inside the monad, and it doesn't ever need to come out.

In `magrittr` you could do something similar:

```{r}
1:5      %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

`magrittr` is standard pipeline, chaining data to output data. `Rmonad` is
quite different, it uses builds monadic sequences, which preserve state between
calls. The preserved state allows us to access data internal to the pipeline:

```{r}
1:5      %$>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The `%v>%` variant of the bind operator stores the results as they are passed.

Now lets look at warnings handling.

```{r}
-1:3     %$>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

`Rmonad` intercepts all errors, warnings, and messages and anchors them to the
function that produced them. Similarly for errors:

```{r}
letters  %$>%
    sqrt %v>%
    sqrt %>>%
    sqrt
```

The input to the first `sqrt` failed, and was coupled to the resultant error.
Contrast this with `magrittr`:

```{r, eval=FALSE}
letters  %>%
    sqrt %>%
    sqrt %>%
    sqrt
```

Also note that a value was still produced. `Rmonad` stores the last successful
value. It will never use this value, though, unless you use a specific operator
(which we will see in a bit).

If you want to extract the result from the monad, you can use the `esc`
function:

```{r}
1:5 %$>% sqrt %>% esc
```

Note the use of `$>$` not `%>>%`, this is because `esc` acts on the monad, not
the value the monad stores. If the monad is in a failed state, `esc` will raise
an error.


Here is a more substantial example

```{r}
# convert to tibbles for cleaner printing
r1 <- read.table("asdfdf") %$>% tibble::as_data_frame %>>% colSums %>>% mean
r2 <- iris %$>% tibble::as_data_frame %>>% colSums %>>% mean
r3 <- cars %$>% tibble::as_data_frame %>>% colSums %>>% mean
```

You may have noticed that the first operator in each chain is `%$>%`, whereas
the following operators are `$>>$`. The former operator takes the left hand
value and wraps it in a monad, and then performs the left hand function on its
value. The `$>>$` operator, takes a monadic container on the left and applies
its value (if it didn't fail) to the function on the right, then unifies the
history.


# Branching out

If you want to perform an operation on a value inside the chain, but don't want
to pass it, you can use the branch operator `%>^%`.

```{r}
pass(rnorm(30)) %>^% plot(xlab="index", ylab="value") %>>% mean
```

This stores the result of `plot` in a branch off the main pipeline. This means
that `plot` could fail, but the rest of the pipeline could continue. You can
store multiple branches.

```{r}
rnorm(30) %>^% plot(xlab="index", ylab="value") %>^% summary %>>% mean
```

Branches can be used as input, as well.

```{r}
x <- 1:10 %>^% dgamma(10, 1) %>^% dgamma(10, 5) %^>% pmax()
x
x@history[[2]]@branch
```

Note the branches could be long monadic chains themselves, which might have
their own branches.

The `%>_%` operator is useful when you want to include a function inside a
pipeline that should be bypassed, but you want the errors, warnings, and
messages to pass along with the main. This can be used make assertions about
the data inside a pipeline.

```{r}
is_positive <- function(x) { stopifnot(x > 0) }
rnorm(30) %>_% is_positive %>>% mean
```

This can also be used for documentation

```{r}
# note is just `function(...) { }`, here I use it to document, since
# Rmonad shows the functions called via NSE.
rnorm(30) %>_% note("I am about to take the mean") %>>% mean
```

Sometimes failure is not the end of the world. For example, we might want to
try several alternatives functions, and use the first that works. 


# Handling error

```{r}
1:10 %$>% colSums %?>% sum
```

Here we will do either `colSums` or `sum`. The pipeline fails only if both
fail.

This operator can also be used as a pure try-catch:

```{r}
id <- function(x) x
iris %$>% tibble::as_data_frame %>>% colSums %?>% id %>>% summary
cars %$>% tibble::as_data_frame %>>% colSums %?>% id %>>% summary
```

In this way, we can make chains of operations which may fail for some inputs.
These failures are recorded in the monad, but don't scream and break things.

Sometimes you want to ignore the previous failure completely, and make a new
call -- for example in reading files:

```{r}
# try to load a cached file, on failure rerun the analysis
"analyasis_cache.tab" %$>% read.table %?<% the_analysis(x)
```

```{r, eval=FALSE}
read(datafile) %,=% "data"   %,,%
read(config)   %,=% "config" %,>% dothething
```
