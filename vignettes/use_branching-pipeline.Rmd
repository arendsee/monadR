---
title: "Rmonad: branching pipelines"
author: "Zebulun Arendsee"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Branching Pipelines}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

There are several levels at which a pipeline may branch

# Calling single functions for effects

The `%>_%` operator is useful when you want to include a function inside a
pipeline that should be bypassed, but you want the errors, warnings, and
messages to pass along with the main. This can be used make assertions about
the data inside a pipeline.

```{r}
is_positive <- function(x) { stopifnot(x > 0) }
rnorm(30) %>_% is_positive %>>% mean
```

Or you can cache an intermediate result


```{r, eval=FALSE}
cars %>_% write.csv(file="cars.tab") %>>% summary
```

Or to plot a value along with a summary

```{r}
cars %>_% plot(xlab="index", ylab="value") %>>% summary %>% forget
```

I pipe the final monad into `forget`, which is (like `esc`) a function for
operating on monads. `forget` removes history from a monad. I do this just to
de-clutter the output.

You can call multiple effects

```{r, eval=FALSE}
cars                                 %>_%
    plot(xlab="index", ylab="value") %>_%
    write.csv(file="cars.tab")       %>>%
    summary %>% forget
```

# Branching Out

If you want to perform an operation on a value inside the chain, but don't want
to pass it, you can use the branch operator `%>^%`.

```{r}
rnorm(30) %>^% qplot(xlab="index", ylab="value") %>>% mean %>% unbranch
```

This stores the result of `qplot` in a branch off the main pipeline. This means
that `plot` could fail, but the rest of the pipeline could continue. You can
store multiple branches.

```{r}
rnorm(30) %>^% plot(xlab="index", ylab="value") %>^% summary %>>% mean
```

Branches can be used as input, as well.

```{r}
x <- 1:10 %>^% dgamma(10, 1) %>^% dgamma(10, 5) %^>% cor
x
unbranch(x)
```

Note the branches could be long monadic chains themselves, which might have
their own branches. The `unbranch` function recursively extracts all branches
from the tree.


# Chains of chains

If you want to connect many chains, all with independent inputs, you can do so
with the `%__%` and `%v__%` operators.

```{r}
runif(10) %>>% sum %v__%
rnorm(10) %>>% sum %v__%
rexp(10)  %>>% sum
```

The `%v__%` operator records the output of the lhs and evaluates the rhs into
an Rmonad. If you don't care about the output, you can use `%__%`, which simply
replaces the rhs value with lhs value (while, of course, propagating state).

If you won't the success of one stage to be dependent on the prior stage, you
can use the branch operator:

```{r}
x <- runif(10) %>>% sum %^__%
     rnorm(10) %>>% sum %^__%
     rexp(10)  %>>% sum
unbranch(x)
```

Note the use of magrittr's `%>%` to perform an operation on the monad itself,
rather than its value.

`unbranch` returns a list of all branches in the tree. Here is a more dramatic picture.

```{r}
runif(10)  %>>% abs %>^% sum %^__%
rnorm(10)  %>>% abs %>^% sum %^__%
rnorm("a") %>>% abs %>^% sum %^__%
rexp(10)   %>>% abs %>^% sum %>%
    unbranch
```

# Multiple inputs

So far our pipelines have been limited to either linear paths or the somewhat
awkward branch merging. An easier approach is to read inputs from a list. But
we want to be able to catch errors resulting from evaluation of each member of
the list. We can do this with `list_meval`.

```{r}
lsmeval(
    "yolo",
    stop("stop, drop, and die"),
    runif("simon"),
    k = 2
)
```

This returns a monad which fails if any of the components evaluate to an error.
But it does not toss the rest of the inputs, instead returning a clean list
with a NULL filling in missing pieces. Constrast this with normal list evaluation:

```{r, error=TRUE}
list( "yolo", stop("stop, drop, and die"), runif("simon"), 2)
```

`lsmeval` records each failure in each element of the list independently.

This approach can also be used with the infix operator `%*>%`.

```{r, eval=FALSE}
lsmeval(read.csv("a.csv"), read.csv("b.csv")) %*>% merge
```

Now, of course, we can add monads to the mix 

```{r, eval=FALSE}
lsmeval(
    a = read.csv("a.csv") %>>% do_analysis_a,
    b = read.csv("b.csv") %>>% do_analysis_b,
    k = 5
) %*>% joint_analysis
```

Monadic list evaluation is the natural way to build large programs from smaller
pieces.

# Annotating steps

As our pipelines become more complex, it becomes essential to document them. We
can do that as follows:

```{r}
runif(5) %>>% abs %>% doc(

    "Alternatively, the documentation could go into a text block below the code
    in a knitr document. The advantage of having documentation here, is that it
    is coupled unambiguously to the generating function. This is a monadic
    interpretation of literate programming. These annotations, together with
    the ability to chain chains of monads, allows whole complex workflows to be
    built, with the results collated into a single monad. All errors propagate
    exactly as errors should, only affecting downstream computations. The final
    monad can be converted into a markdown document and automatically generated
    function graphs."

                  ) %>^% sum %__%
rnorm(6)   %>>% abs %>^% sum %v__%
rnorm("a") %>>% abs %>^% sum %__%
rexp(6)    %>>% abs %>^% sum %T>%
  {print(mtabulate(.)) } %>% missues
```

Note `%T>%` is a `magrittr` operator. It allows execution of the rhs function
on the lhs *monad* and bypasses the result.
